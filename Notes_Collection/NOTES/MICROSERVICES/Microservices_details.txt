-> In Microservice , all enviorement configurations are stored in the GIT repository

-> A single microservice can have multiple enviorement and multiple enviorenment can have multiple instances , that is why all the enviorenment configuration are maintained In Git repo and that will be accessible throught Spring Clould Config server

-> all the microservices uses the configuartion from Git repo through SpringCloudConfig server.


=> Here we have two microservices , Limit Microservice and Currence&Exchange Microservice

=>Limit Service

Spring Initializer  >> create a new SpringBoot project >> add dependency { sprimg web , dev tools , actuator , config client }


upgrade JDK 8 to JDK11
https://crunchify.com/how-to-fix-java-lang-unsupportedclassversionerror-class-has-been-compiled-by-a-more-recent-version-of-the-java-runtime/


=> Spring cloud config server

spring Initializer >> craete a new project form spring initializer >> add dependency { dev tools , config server }




=>Cuurency-conversion-service will connect with currency-exchange-service through RestTemplate
=>Currency-conversion-service will contain the RestTemplate code as currency-conversion-service is the comsumer service , based on the currency-exchage-service value, output will be generated by currency-conversion-service


======>>>>
FeignClient = FeignClient for connecting/communicating with Microservice

==========================================================================================================================================================================================================================================================================================================================

*** Note :-

==>> Lunching web service on different port
Eclipse >> Java application >> Rgt Click >> Run Configuration >> duplicate the instance on the left side >> Arguments >> -Dserver.port=8002



==========================================================================================================================================================================================================================================================================================================================

Ribbon - Load Balancer
***********************

=> Ribbon distribute the load among the other/configured Web Services
=> For example - 
currency-conversion service is connected with the currency-exchange service
in order to communicate with the multiple instance of the currency-exchange service, Ribbon (Load Balancer) is used
Ribbon will distribute the Load among the different instances of the currency-exchange service

steps -
--------

1) Add Ribbon dependency on pom.xml file


-->  SBV >2.0.0M3 and SBV >2.0.0 , use dependency

<!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-ribbon -->
    <dependency>
           <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
          <version>2.2.5.RELEASE</version>
    </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-loadbalancer -->
    <dependency>
         <groupId>org.springframework.cloud</groupId>
         <artifactId>spring-cloud-starter-loadbalancer</artifactId>
         <version>2.2.4.RELEASE</version>
        </dependency>
       <dependency>


-->  SBV 3 onwards , use below dependency

<dependency>
  <groupId>org.springframework.org</groupId>
  <artifactId>spring.cloud.starter.ribbon</artifactId>
</dependency>


2)Add @RibbonClient annotation on the FeignClient proxy interface

//@FeignClient(name="currency-exchange-service" , url = "localhost:8000") --without Ribbon
//below is with Ribbon LB
//@FeignClient(name="currency-exchange-service") //currency-conversion-service connects with currency-exchange-service
@FeignClient(name="netflix-zuul-apigateway-server") //with api gateway zuul
@RibbonClient(name = "currency-exchange-service") //with Eureka
public interface CurrencyExchangeServiceProxy {
  
  //@GetMapping("/currency-exchange/{from}/to/{to}") //without api gateway-zuul
  @GetMapping("/currency-exchange-service/currency-exchange/{from}/to/{to}") //with api gateway zuul --http:8765/{appname}/uri
  public CurrencyConversionBean sendCurrencyExchangeValue(@PathVariable("from") String from , @PathVariable("to") String to);
  
  }

3)Update application.properties file , with the web service url with different ports

File - application.properties (currency-conversion-service) [web service which is connected with the other web service]
--------------------------------------------------------------
spring.application.name=currency-conversion-service
server.port = 8100

spring.config.import = optional:configserver:localhost:8888

#no required if we have eureka
currency-exchange-service.ribbon.listOfServers = http://localhost:8000,http://localhost:8001





==========================================================================================================================================================================================================================================================================================================================


Eureka - Naming Server (netflix-eureka-server)
************************************************

=>> Default port for Eureka naming server = 8761

-->> Naming server is required for 2 reasons
i) service registry
ii) service discovery

-->> with the help of the Naming server , we can track which are the web services are currently running and the number of instances of the web services
-->> eureka has its own UI for displaying the list of servers

service registry
-----------------
-->> service registry means web service can be registered on the Eureka - Naming server

service discovery
------------------
-->> with the help of the service discovery, load balancing can be implemented, as number of instances of the web service is available on the naming server


Setting up - Eureka - Naming server
************************************
Steps :-

1)Create a Springboot application for Eureka Naming Server

Spring Initializer >> Project Name - netflix-eureka-naming-server >> Add Dependency [ Eureka Server , Config Client, DevTools , Actuator ]


2)Enable eureka server annotation on main class

@SpringBootApplication
@EnableEurekaServer


3)update application.properties

spring.application.name= netflix-eureka-naming-server
server.port = 8761

spring.config.import = optional:configserver:localhost:8888

eureka.client.fetch-registry = false
eureka.client.register-with-eureka = false


Connecting Microservice with Eureka Naming server
***************************************************

Project/Web Sevice = currency-conversion-service

Steps :-
---------

1)Add Eureka server dependency on pom.xml file

For SBV >=2.0
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>  

OR SBV >=3

  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-eureka/artifactId>
    </dependency>


2)Enable Eureka server , add @EnableDiscoveryClient on Main class

@SpringBootApplication
@EnableFeignClients("com.springDemo.microservice.currencyconversionservice")
@EnableDiscoveryClient


3)Update application.properties file - add eureka server URL
+
+
+
#
#Eureka configuration

eureka.client.service-url.default-zone = http://localhost:8761/eureka

** Note-
After making the Eureka server up
and then make the other microservice up
http://localhost:8761/eureka


==========================================================================================================================================================================================================================================================================================================================


API Gateway - Zuul API Gateway
*********************************

>>API Gateway is required when we would need

Authentication , Authorization and Security
Rate Limits
Fault Tolerance
Service Aggregation



Setting up Zuul API Gateway (server) :- 
-------------------------------------

Steps :-
--------

1)Create a springboot application for netflix-zuul-api-gateway-server using spring-initializer

    add dependency - [zuul , Eureka Discovery , DevTools , Actuator]

2)Add Enable zull annotaion on main class

    @SpringBootApplication
    @EnableZuulProxy
    @EnableDiscoveryClient (//for registering the web service on Eureka naming server)

3)Update application.properties file
-->> for adding service name and port and also add the eureka server URL

    spring.application.name=netflix-zuul-apigateway-server
    server.port=8765

    eureka.client.service-url.default-zone= http://localhost:8761/eureka

4)Implementing Zuul Logging Filter

-->> create a class that extends ZuulFilter
  public class ZuulLoggingFilter extends ZuulFilter{
  
  //logger
  private Logger logger = (Logger) LoggerFactory.getLogger(this.getClass());

  public boolean shouldFilter() {
    // should need a filter or not , initiallay set to false
    return true;
   }
  
  @Override
  public String filterType() {
    // pre = every service call should be at first go through via api-gateway
    //post , error
    return "pre";
  }

  public Object run() throws ZuulException {
    // run() method should contains the main business logic
    
    HttpServletRequest request = RequestContext.getCurrentContext().getRequest();
    
    logger.info("request {} -> request uri {}" , request , request.getRequestURI());
    
    
    return null;
  }
  
  @Override
  public int filterOrder() {
    // set filter order to 1, if we have multiple filters i.e. security filter , logging filter etc, then we can set filter according to that
    return 1;
   }
   }


Setting up Zuul api gateway between Microservice Invocation
-------------------------------------------------------------

Steps -
--------

1)point the netflix-zuul-api-gateway service on @Feignclient() , Feign proxy

==>> say for example currency-conversion-service is calling currency-exchange-service,
so, two service is connected/communicated with Feign proxy
so, on the Feign proxy interface , connect the zuul-api-gateway server via @FeignClient annotation 

==>> whenever we need to call any webservice via API Gateway , it follows the below URL patten 

http://localhost:zuul-api-PORT/{application-name}/API-end-point

**{application-name} = taken from the application.properties file of the webservice

File - CurrencyExchangeFeignProxy.java(Interface)
--------------------------------------------------

//@FeignClient(name="currency-exchange-service" , url = "localhost:8000") --without Ribbon
//below is with Ribbon LB
//@FeignClient(name="currency-exchange-service") //currency-conversion-service connects with currency-exchange-service
@FeignClient(name="netflix-zuul-apigateway-server") //with api gateway zuul
@RibbonClient(name = "currency-exchange-service")
public interface CurrencyExchangeServiceProxy {
  
  //@GetMapping("/currency-exchange/{from}/to/{to}") //without api gateway-zuul
  @GetMapping("/currency-exchange-service/currency-exchange/{from}/to/{to}") //with api gateway zuul --http:8765/{appname}/uri
  public CurrencyConversionBean sendCurrencyExchangeValue(@PathVariable("from") String from , @PathVariable("to") String to);
  
  }

Note -

Webservice1 -> API-Gateway -> Webservice2

Zuul-api-gateway URL pattern
http://localhost:zuul-PORT/{application-name}/API-end-point



==========================================================================================================================================================================================================================================================================================================================

Zipkin - Distributed Tracing Server
**************************************

=>> distributed tracing server is required to trace the request amoung the microservice flow
=>> a single request is passing through multiple webservices in an Microservice architecture
==>> in order to trace the request, a unique ID is assigned to the request by the Spring Cloud Sleuth. For tracing purpose
=>> log files from the different microservice/webservice is put into RabbitMq (message queue system) and then pass it into distributed tracing server
==>> all the microservices logs are centralized into single server called Zipkin Distributed tracing server.

==>>Distributed tracing server - Zipkin provides the UI for the tracimg the requests

Microservice -> RabbitMq -> Zipkin-server

Implementing Spring Cloud Sleuth
---------------------------------

Steps :-
********

1) Add spring cloud sleuth dependency on pom.xml file

->> Add spring-cloud-sleuth dependency on every micriservice/webservice

<!-- dependency for spring cloud sleuth which adds id to the service request -->
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>

2)Add a sampler class on Main class
=>> Sampler class is required in order to intercept what all request

@SpringBootApplication
@EnableZuulProxy
@EnableDiscoveryClient
public class NetflixZuulApiGatewayServerApplication {

  public static void main(String[] args) {
    SpringApplication.run(NetflixZuulApiGatewayServerApplication.class, args);
  }
  
  @Bean
  public Sampler defaultSampler(){
    return Sampler.ALWAYS_SAMPLE;
  }

}


Installing RabbitMQ
*********************
=>>Before installing rabbitMQ we need to install Earlang

1)https://www.rabbitmq.com/install-windows.html
Install the Erlang

Reference for Installing RabbitMQ
https://github.com/in28minutes/spring-microservices


=>> RabbitMQ runs as the background application and it it avilable from Main menu



Setting up Distributed Tracing with Zipkin
*********************************************

=>> Zipkin server is avilable as jar file
=>> Google -> quick start open zipkin -> zipkin jar will autometically downloaded if we select 

For download the zipkin jar =  https://zipkin.io/pages/quickstart

For running the zipkin server 
CMD =>

set RABBIT_URI=amqp://localhost
java -jar zipkin-server-2.7.0-exec.jar


For view the zipkin dashboard
browse to = http://localhost:9411/zipkin
zipkin port = 9411



Connecting Microservices to Zipkin
**************************************

** If you are using Spring Boot Release >= 2.1.*, you would need to use spring-cloud-starter-zipkin and spring-rabbit instead 
of spring-cloud-sleuth-zipkin and spring-cloud-starter-bus-amqp.

**You would need to make this change in THREE pom.xmls - in currency-conversion-service, 
currency-exchange-service, and zuul-api-gateway projects

1) Need to add maven dependency for zipkin and rabbitMq


New Dependencies

    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-zipkin</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.amqp</groupId>
      <artifactId>spring-rabbit</artifactId>
    </dependency>

OLD Dependencies to be Replaced

    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-sleuth-zipkin</artifactId>
    </dependency>
 
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-bus-amqp</artifactId>
    </dependency>


Note-

Sequence of execution of services 

1.Eureka Naming server
2.Zipkin server (through CMD jar file run)
3.currency-exchange-service
4.currency-conversion-service
5.netflix-zuul api gateway  server


===============================================================*******************==========================================================================================================================================*******************===========================================================================

SB V3
******

=>> Load balancer is present in the spring-cloud-netflix-eureka (Eureka) server
==>> previous version of Spring boot Load balancing has been done with the help of Ribbon
==>> In recent version of SpringBoot i.e. SBV3 ...with the help of Eureka server and Feign we can implement the client side load balancing as Load balancer is already predent in the Eureka server 

Spring Cloud API Gateway
**************************
=>> previously zull-api gateway was used for the api-gateway but zull is not supported in SB v3
=>> Spring cloud API gateway is used

steps:
------

1) Create a springboot starter project for spring-cloud-API-Gateway

Add dependency - [devtools , Actuator , Eureka Discovery Client , Gateway(Spring Cloud Routing)]


2)Update application.properties file

File - application.properties
------------------------------
spring.application.name= apigateway
server.port=8765
eureka.client.service-url.default-zone= http://localhost:8761/eureka

spring.cloud.gateway.discovery.locator.enabled=true 
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true

*****API gateway URL - http://localhost:8765/{application-name}/api-end-point-name


=============================================================================================================================================================

SB V3
******

CIRCUIT BREAKER - Resilience4j
********************************

=>>In case of the Microservice architecture, if any one of the Microservice is slow down then the entire chain goes down

=>>Circuit Breaker framework , returns the fallback response if any Microservice is down

=>>it can reduce load, if we have come to know any Microservice is slow, then instead of hitting the Microservice multiple time to increase the load on it, it will return the default response back by not hitting the Microservice (Circuit Breaker pattern)

=>>retry request in case of temporary failure , if there is temporary failure from the Microservice4 then retry request for certain amount of time and return the deafult response even after getting the multiple temporary failure.

@Retry -> by default request(Retry) the Microservice for 3 times and then return the errorpage/fallback method/default response



=>>Rate limiting , allow certain number of calls to the Microservice for the specific interval of time. 








Steps :- (Impelmenting Circuit Breaker - Resilience4j in microservice)
*******

1)Add dependency on pom.xml file

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>

    <dependency>
      <groupId>io.github.resilience4j</groupId>
      <artifactId>resilience4j-spring-boot2</artifactId>
    </dependency>

2)Update application.properties file

File - application.properties
---------------------------------

spring.application.name=currency-exchange
server.port=8000

spring.jpa.show-sql=true
spring.datasource.url=jdbc:h2:mem:testdb
spring.h2.console.enabled=true

eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka

#
#configuation for resilience4j
#
resilience4j.retry.instances.sample-api.maxRetryAttempts=5
resilience4j.retry.instances.sample-api.waitDuration=1s
resilience4j.retry.instances.sample-api.enableExponentialBackoff=true

#Ratelimiter configuration
#
#resilience4j.circuitbreaker.instances.default.failureRateThreshold=90
resilience4j.ratelimiter.instances.default.limitForPeriod=2
resilience4j.ratelimiter.instances.default.limitRefreshPeriod=10s

#bulkhead configuration
#
resilience4j.bulkhead.instances.default.maxConcurrentCalls=10
resilience4j.bulkhead.instances.sample-api.maxConcurrentCalls=10

spring.sleuth.sampler.probability=1.0

##spring.zipkin.baseUrl=http://localhost:9411/


3)Adding Circuit breaker annotation on Controller (Adding Retry,fallback method)

@RestController
public class CircuitBreakerController {
  
  private Logger logger = 
        LoggerFactory.getLogger(CircuitBreakerController.class);
  
  @GetMapping("/sample-api")
  //@Retry(name = "sample-api", fallbackMethod = "hardcodedResponse")
  //@CircuitBreaker(name = "default", fallbackMethod = "hardcodedResponse")
  //@RateLimiter(name="default")
  @Bulkhead(name="sample-api")
  //10s => 10000 calls to the sample api
  public String sampleApi() {
    logger.info("Sample api call received");
//    ResponseEntity<String> forEntity = new RestTemplate().getForEntity("http://localhost:8080/some-dummy-url", 
//          String.class);
//    return forEntity.getBody();
    return "sample-api";
  }
  
  public String hardcodedResponse(Exception ex) {
    return "fallback-response";
  }
}


Note - 
Reference - https://resilience4j.readme.io/docs/circuitbreaker

@CircuitBreaker(name = "default", fallbackMethod = "hardcodedResponse") = return the fallback response without hitting the down microservice multiple time

when a microservice is down , then circuit breaker will call the microservice for the certain number of time (that is called a threshold value for calling microservice) then the circuitbreaker will return the fallback response without hitting the microservice again.


@RateLimiter =
10s => 10000 calls to the sample api
number of webservice/microservice call will be performed in specific time


@Bulkhead= number of maximum concurrent calls can be performed


==========================================================================================================================================================================================================================================================================================================================

PORT Standardization
***********************

APPLICATION                        PORT
-------------------------------------------------------
Limits Microservices               8080.8081,...
Spring Cloud Config server         8888
Currency Exchange Microservice     8000,8001,8002,...
Currency Conversion Microservice   8100,8101,8102,...
Netflix Eureka Naming Server       8761
API Gateway                        8765
Zipkin Distributed Tracing server  9411



=============>>>>>>=======================================================================================================================================================================================================================================================================================================

RabbitMq Install
*******************

https://www.rabbitmq.com/install-windows.html

->before installing RabbitMQ , we need to install erlang



==========================================================================================================================================================================================================================================================================================================================

DOCKER With Microservices
***************************

-->> docker images are stored in the docker hub - hub.docker.com
-->> Images = Images are the static version 
-->> Container = Container is the running version of the image 

1)Docker commands

CMD >>

docker --version
docker run in28min/todo-rest-api-h2:1.0.0.RELEASE

docker run -p 5000:5000 in28min/todo-rest-api-h2:1.0.0.RELEASE
{-p 5000:5000 => -p (hostPort):(containerPort) }

docker run -p 5000:5000 -d in28min/todo-rest-api-h2:1.0.0.RELEASE
{-d = detach mode means run the container as the background process}

docker run -p 5001:5000 -d in28min/todo-rest-api-h2:1.0.0.RELEASE
[if we craete a another container, then it need to be run on different host post]

docker container ls

docker log -f 56789 
(56789 = initial 5 digit number of dockerid generated after run the container)

docker images

docker container ls -a
(-a = returns the list of container with running state as well as exited state )

docker container stop 38679
(38679 = initial 5 digit docker container id)

Docker Container Commands
--------------------------
CMD >>>

docker container run -p 5000:5000 -d in28min/todo-rest-api-h2:1.0.0.0.RELEASE

docker container pause 5678  (pause the container - stop the execution of the current state )
docker logs -f 5678
docker container unpause 5678
docker container inspect 5678
docker cotainer ls -a
docker container prune (remove all stoped container)
docker container ls
docker container stop

-------------------------------------------------------------------------------------------------------------------------------------------------------------
**Note-
docker container stop 1b1
docker container kill 987

stop => SIGTERM => Gracefully shutdown (stop command gives enough time say 10sec for gracefully shutdown the container)
kill => SIGKILL => Immediately terminates the process

**Note - Kill command will immediately kill the conatiner...and kill command is not adviseble
-------------------------------------------------------------------------------------------------------------------------------------------------------------

docker container ls
docker logs -f 987
docker container kill 987


docker conatiner ls
docker container prune
docker container ls -a
docker run -p 5000:5000 -d restart=always in28min/todo-rest-api-h2:1.0.0.RELEASE

docker events
docker top c750 (list number of process running under container)
docker stats
docker run -p 5000:5000 -m 512m --cpu-quota 50000 -d in28min/todo-resp-api-h2:1.0.0.RELEASE
docker system df

**Note = --cpu-quota >>> 100000 = 100% (100 thousand is equal to 100%)
                     >>> 5000 = 5%


==========================================================================================================================================================================================================================================================================================================================

Distributed Tracing - zipkin Distributed Tracing Server (using DOCKER)
************************************************************************

-->>In case of the Microservices architechture , multiple microservices or module are connected with each other i.e. complex call chain
-->>In order to trace the bug/request between the Microservices call , Distributed Tracing server is required 
-->>Zipkin Distributed Tracing server

-->>>All the Microservices are connected with the Distributed Tracing Server(Zipkin) and which is then connected with the Database(DB)

Launching Zipkin Container using Docker
----------------------------------------
Port = 9411
For zipkin Container >> Google >> openzikin/zipkin docker

-->>Instead of creating seperate Java project for Zipkin Distributed Tracing server we launch the Zipkin container using docker

CMD
docker run -p 9411:9411 openzipkin/zipkin:2.23

-->>> Launch the Zipkin server on browser
http://localhost:9411/zipkin/


================================================================================================================================================================================================================

Monitoring , Observability and OpenTelementry
************************************************

Monitoring = Gather data - metrics , logs and traces
Observability = Get Intelligence - AI/Ops and Anomoly detection
OpenTelementry = Collections of Tools,APIs and SDK to instrument,collect,generate and export Telementry data
all applications are having logs,metrices,traces
so,one standard for logs ,metrics and traces


==========================================================================================================================================================================================================================================================================================================================

Connecting Microservice with Zipkin - SBV3
******************************************* 

Reference - https://github.com/in28minutes/spring-microservices-v3/blob/main/v3-upgrade.md
https://github.com/in28minutes/spring-microservices-v3

Steps-
-------
1)Add dependency

(Sleuth/Micrometer) - depending on the SpringBoot version 2/3
(Brave/OpenTelementry) - depending on the SpringBoot version 2/3
Zipkin

2)Update application.properties

#spring.sleuth.sampler.probability=1.0 #SB2
management.tracing.sampling.probability=1.0 #SB3
logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}] #SB3



SpringBoot Version 2 (SB2) - Zipkin Implementation
----------------------------------------------------

<!-- SB2  : Sleuth (Tracing Configuration) 
            > Brave (Tracer library) 
            > Zipkin 
-->

Note - 
** Spring Sleuth for adding Tracking Id on the request
** Brave as Bridge - Provides Tracking Library
** Zipkin Server as Distributed Tracing Server


<!-- 
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-brave</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-zipkin</artifactId>
</dependency>
-->



SpringBoot Version 3 (SB3) - Zipkin Implementatiom
----------------------------------------------------


<!-- SB3 :  Micrometer 
            > OpenTelemetry 
            > Zipkin 
-->

<!-- Micrometer - Vendor-neutral application observability facade. 
    Instrument your JVM-based application code without vendor lock-in.  
    Observation (Metrics & Logs) + Tracing.
-->

Note -
** Micrometer provides or add the Tracking Id on the request
** OpenTelementry - as Bridge - Provides metrices,logs and Traces
** Zipkin - Distributed Tracing Server


<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-observation</artifactId>
</dependency>

<!-- OPTION 1: Open Telemetry as Bridge (RECOMMENDED) -->
<!-- Open Telemetry 
    - Simplified Observability (metrics, logs, and traces) -->

<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-tracing-bridge-otel</artifactId>
</dependency>

<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-exporter-zipkin</artifactId>
</dependency>


<!-- OPTION 2: Brave as Bridge -->

<!--
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-tracing-bridge-brave</artifactId>
</dependency>

<dependency>
    <groupId>io.zipkin.reporter2</groupId
    <artifactId>zipkin-reporter-brave</artifactId>
</dependency>
-->

-------------------------------------------------------------------------------------------------------------------------------------------------------------

==>>Connecting Microservice with Zipkin procedure is same for all Microservice

==>>For SpringBoot version 3 or above , Feign client implementaion would require additional depnedency
<!-- COMMON CHANGES + -->
<!-- Enables tracing of REST API calls made using Feign - V3 ONLY-->
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-micrometer</artifactId>
</dependency>


==========================================================================================================================================================================================================================================================================================================================


Setup Microservices - Creating Docker Container Images - Create own docker image for Micriservice 
***************************************************************************************************

Docker Reference
Spring Boot 2.4+ - https://github.com/in28minutes/spring-microservices-v2/tree/main/04.docker

Spring Boot 3.0+ - https://github.com/in28minutes/spring-microservices-v3/tree/main/04.docker

Steps:

1)Download docker project from the GitHub repo of in28min - https://github.com/in28minutes/spring-microservices-v2/tree/main/04.docker

2)Import the Microservives on the Eclipse IDE

3)Create a Container Image - Open pom.xml file of the Microservice for which we would need to create an Image

File Name - pom.xml
--------------------

<build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <image>
                        <name>in28min/mmV2-${project.artifactId}:${project.version}</name>
                        <pullPolicy>IF_NOT_PRESENT</pullPolicy>
                    </image>
                </configuration>
            </plugin>
        </plugins>
</build>

4)Maven Build
project folder >> Right Click >> Run as Maven Build >> Goal = spring-boot:build-image -DskipTests 

{where DskipTests is optional and it is not need to apply on real time project}

5)Run Docker Container with the created Image
CMD
docker run -p 8000:8000 in28min/mmv2-currency-exchange-service:0.0.1-SNAPSHOT

Note -
*** above we have created Image for the currency-exchange-service


==========================================================================================================================================================================================================================================================================================================================


DOCKER Compose
****************

-->>Docker compose is preinstalled with the Docker
-->>in order to run the multiple microservices , docker compose has the yaml file which contains all the instructions/details for the microsrvices to run

CMD 

docker-compose --version
docker-compose up

example of docker-compose yaml file
File - docker-compose-06final.yaml
-----------------------------------
version: '3.7'

services:

  currency-exchange:
    image: in28min/mmv2-currency-exchange-service:0.0.1-SNAPSHOT
    mem_limit: 700m
    ports:
      - "8000:8000"
    networks:
      - currency-network
    depends_on:
      - naming-server
      - rabbitmq
    environment:
      EUREKA.CLIENT.SERVICEURL.DEFAULTZONE: http://naming-server:8761/eureka
      SPRING.ZIPKIN.BASEURL: http://zipkin-server:9411/
      RABBIT_URI: amqp://guest:guest@rabbitmq:5672
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_ZIPKIN_SENDER_TYPE: rabbit

  currency-conversion:
    image: in28min/mmv2-currency-conversion-service:0.0.1-SNAPSHOT
    mem_limit: 700m
    ports:
      - "8100:8100"
    networks:
      - currency-network
    depends_on:
      - naming-server
      - rabbitmq
    environment:
      EUREKA.CLIENT.SERVICEURL.DEFAULTZONE: http://naming-server:8761/eureka
      SPRING.ZIPKIN.BASEURL: http://zipkin-server:9411/
      RABBIT_URI: amqp://guest:guest@rabbitmq:5672
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_ZIPKIN_SENDER_TYPE: rabbit

  api-gateway:
    image: in28min/mmv2-api-gateway:0.0.1-SNAPSHOT
    mem_limit: 700m
    ports:
      - "8765:8765"
    networks:
      - currency-network
    depends_on:
      - naming-server
      - rabbitmq
    environment:
      EUREKA.CLIENT.SERVICEURL.DEFAULTZONE: http://naming-server:8761/eureka
      SPRING.ZIPKIN.BASEURL: http://zipkin-server:9411/
      RABBIT_URI: amqp://guest:guest@rabbitmq:5672
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_ZIPKIN_SENDER_TYPE: rabbit

  naming-server:
    image: in28min/mmv2-naming-server:0.0.1-SNAPSHOT
    mem_limit: 700m
    ports:
      - "8761:8761"
    networks:
      - currency-network

#docker run -p 9411:9411 openzipkin/zipkin:2.23

  zipkin-server:
    image: openzipkin/zipkin:2.23
    mem_limit: 300m
    ports:
      - "9411:9411"
    networks:
      - currency-network
    environment:
      RABBIT_URI: amqp://guest:guest@rabbitmq:5672
    depends_on:
      - rabbitmq
    restart: always #Restart if there is a problem starting up

  rabbitmq:
    image: rabbitmq:3.8.12-management
    mem_limit: 300m
    ports:
      - "5672:5672"
      - "15672:15672"
    networks:
      - currency-network


networks:
  currency-network:


==========================================================================================================================================================================================================================================================================================================================

KUBERNETES - Orchestration tool
***********************************

Cloud Platform used = google cloud (kubernetes cloud engine)

Kubernetes Command - Ref
-------------------------

https://github.com/in28minutes/spring-microservices-v2/tree/main/05.kubernetes#commands



Import projects into eclipse - Kubernetes
-------------------------------------------

Ref = https://github.com/in28minutes/spring-microservices-v3/tree/main/05.kubernetes



